-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
      READ      -> sprintf ("READ")
    | WRITE     -> sprintf ("WRITE")
    | BINOP (s) -> sprintf ("BINOP %s", s)
    | LD    (x) -> sprintf ("LD %s", x)
    | ST    (x) -> sprintf ("ST %s", x)
    | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) { showSMInsn (i) ++ "\n" }, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c@[stack, state, w], insns) {
--   printf("eval %s\n", w.string);
  case insns of
      { }       -> c
    | i : insns ->
      eval (
        case i of
            READ       ->
              var temp;
              var n;
              var w2;
--               printf("READ\n");
--               printf("world %s\n", w.string);
              temp := readWorld (w);
              n := temp.fst;
              w2 := temp.snd;
--               printf("READ 2\n");
              [n:stack, state, w2]
          | WRITE      ->
--               printf("WRITE\n");
              case stack of
                n : st -> [st, state, writeWorld (n, w)]
              esac
          | BINOP (op) ->
--               printf("BINOP\n");
              case stack of
                x : y : st -> [evalOp (op, x, y):st, state, w]
              esac
          | CONST (n)  -> (*printf("CONST\n");*)[n:stack, state, w]
          | LD (x)     -> (*printf("LD\n");*)[state (x):stack, state, w]
          | ST (x)     ->
              (*printf("ST\n");*)
              case stack of
                n : st -> [st, state <- [x, n], w]
              esac
        esac,
        insns
      )
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  (*printf("evalSM\n");*)
  eval ([{ }, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list 
-- of stack machine instructions
fun compileExpr (expr) {
  case expr of
      Var (v)        -> { LD (v) }
    | Const (i)      -> { CONST (i) }
    | Binop(s, l, r) -> compileExpr (r) +++ compileExpr (l) +++ { BINOP (s) }
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {


  case stmt of
      Assn(v, e)        -> compileExpr (e) +++ { ST (v) }
    | Seq(stmt1, stmt2) -> compileSM (stmt1) +++ compileSM (stmt2)
    | Skip              -> { }
    | Read(v)           -> { READ, ST (v) }
    | Write(e)          -> compileExpr (e) +++ { WRITE }
  esac
}
