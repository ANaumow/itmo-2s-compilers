-- A deep embedding of L0 into Lama

-- Embeds expression operands: strings are 
-- embedded into identifiers, integer constants --- into
-- constants; non-operand expressions are left intact
fun opnd (x) {
  case x of
    #string  -> Var   (x)
  | #unboxed -> Const (x)
  | _        -> x
  esac
}

-- Redefinition of standard infix operators
infix +  at +  (l, r) {Binop ("+",  opnd (l), opnd (r))}
infix -  at -  (l, r) {Binop ("-",  opnd (l), opnd (r))}
infix *  at *  (l, r) {Binop ("*",  opnd (l), opnd (r))}
infix /  at /  (l, r) {Binop ("/",  opnd (l), opnd (r))}
infix %  at %  (l, r) {Binop ("%",  opnd (l), opnd (r))}
infix == at == (l, r) {Binop ("==", opnd (l), opnd (r))}
infix != at != (l, r) {Binop ("!=", opnd (l), opnd (r))}
infix <  at <  (l, r) {Binop ("<",  opnd (l), opnd (r))}
infix <= at <= (l, r) {Binop ("<=", opnd (l), opnd (r))}
infix >  at >  (l, r) {Binop (">",  opnd (l), opnd (r))}
infix >= at >= (l, r) {Binop (">=", opnd (l), opnd (r))}
infix && at && (l, r) {Binop ("&&", opnd (l), opnd (r))}
infix !! at !! (l, r) {Binop ("!!", opnd (l), opnd (r))}

-- Embeds "read" construct; x is expected to be a string (not a "Var")
fun read (x) {
  Read (x)
}

-- Embeds "write" construct; note, e is expression, thus it
-- is embedded using "opnd"
fun write (e) {
  Write (opnd (e))
}

-- Embeds assignment operator; x is expected to be string, e is expression, this
-- it is embeeded using "opnd"
infix ::= before := (x, e) {
  Assn (x, opnd (e))
}

-- Embeds sequential composition
infixr >> before ::= (s1, s2) {
  Seq (s1, s2)
}

-- Returns embedded program (thus, the file has to be recompiled as the
-- program changes)
public fun program () {  
  read ("y") >>
  read ("x") >>
  "z" ::= "x" * 3 + "y" - 2 >>
  write ("y" + "x" + "z") >>
  write ("y" - "z")
}