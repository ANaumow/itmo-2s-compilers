-- Parser

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binopOf(l, op, r) {
  Binop(op, l, r)
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")")));

var exp = memo $ eta (expr({
        [Left, { [s("!!"), binopOf] }],
        [Left, { [s("&&"), binopOf] }],
        [Nona, {
          [(s("==") |
            s("!=") |
            s("<=") |
            s("<") |
            s(">=") |
            s(">")), binopOf] }],
        [Left, { [(s("+") | s("-")), binopOf] }],
        [Left, { [(s("*") | s("/") | s("%")), binopOf] }]
         },
      primary));

var stmt = memo $ eta syntax (kSkip { Skip }                           |
                              kRead s["("] x=lident s[")"] { Read(x) } |
                              kWrite s["("] e=exp s[")"] { Write(e) }  |
                              x=lident s[":="] e=exp { Assn(x, e) });

-- Public top-level parser
public parse = syntax (stmt | stmt1=stmt s[";"] stmt2=parse { Seq(stmt1, stmt2) });
