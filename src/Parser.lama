-- Parser

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binopOf(l, op, r) {
  Binop(op, l, r)
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")")));

var exp = memo $ eta (expr({
        [Left, { [s("!!"), binopOf] }],
        [Left, { [s("&&"), binopOf] }],
        [Nona, {
          [(s("==") |
            s("!=") |
            s("<=") |
            s("<") |
            s(">=") |
            s(">")), binopOf] }],
        [Left, { [(s("+") | s("-")), binopOf] }],
        [Left, { [(s("*") | s("/") | s("%")), binopOf] }]
         },
      primary));

var stmt = memo $ eta syntax (
  kSkip { Skip }                                                       |
  kRead s["("] x=lident s[")"] { Read(x) }                             |
  kWrite s["("] e=exp s[")"] { Write(e) }                              |
  x=lident s[":="] e=exp { Assn(x, e) }                                |
  kIf e=exp kThen ifTrue=parse ifElse=ifTail { If(e, ifTrue, ifElse) } |
  kWhile e=exp kDo body=parse kOd { While(e, body) }                   |
  kDo body=parse kWhile expr=exp kOd { DoWhile(body, expr) }           |
  kFor init=parse s[","] e=exp s[","] progres=parse kDo body=parse kOd { Seq(init, While(e, Seq(body, progres))) }
);

var ifTail = memo $ eta syntax (
  kElif expr=exp kThen thenBody=parse elseBody=ifTail { If(expr, thenBody, elseBody) } |
  -kElse parse -kFi                                                                    |
  kFi { Skip }
);


-- Public top-level parser
public parse = memo $ eta syntax (stmt | stmt1=stmt s[";"] stmt2=parse { Seq(stmt1, stmt2) });
